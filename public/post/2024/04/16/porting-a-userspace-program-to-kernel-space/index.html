<!DOCTYPE html>
<html lang="en-us">
  <head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>Porting a userspace program to Kernel space | Linux kernel programming blog</title>
    <link rel="stylesheet" href="/css/style.css" />
    <link rel="stylesheet" href="/css/fonts.css" />
    <link rel="stylesheet" href="/static/css/custom.css" />
<meta name="google-site-verification" content="m3n6pzMcloBT3cd6VuLuPT6UnxIO7wfNvpd59oC6S14"/>

  </head>

  <body>
    <nav>
    <ul class="menu">
      
      <li><a href="/">Home</a></li>
      
      <li><a href="/post/">Posts</a></li>
      
      <li><a href="/categories/">Categories</a></li>
      
      <li><a href="/about/">About</a></li>
      
    </ul>
    <hr/>
    </nav>

<div class="article-meta">
<h1><span class="title">Porting a userspace program to Kernel space</span></h1>

<h2 class="date">2024/04/16</h2>
</div>

<main>
<p><a href="https://github.com/Rust-for-Linux/"><img class="penguin" src="/static/img/rusty_penguin_10.jpeg" alt="Rusty penguin. Created by DALL·E 3." /></a></p>
<h1 id="why-though">Why though?</h1>
<p><a href="https://infosec.exchange/@dmnk">Domenukk</a>
suggested to port <a href="https://github.com/domenukk/quarto_rs/tree/main">his quarto game</a>
to kernel space.
Because we thought we can.
The idea was that besides changing the imports used from <code>std::</code> to <code>kernel::</code>,
since you <a href="../../../02/25/allocators/">cannot use the stdlib in kernel space</a>,
then <a href="../../../02/02/creating-c-bindings/">adding a few C bindings</a> to interact
with existing kernel code, and making sure that all the functions you use should
not panic and crash the rest of the kernel, the code should globally be the
same. This blog entry gives you an idea how complex the work actually is.</p>
<h1 id="there-is-no-stdinstdout">There is no stdin/stdout</h1>
<p>When you start a program in bash, you usually communicate with the program by
writing to stdout (file descriptor 2) and reading user input from stdin (file
descriptor 1). Those file descriptors are provided to you by the kernel. You can
still pass and receive data from/to the kernel through other mechanisms. For
example, if you register a character device driver, you can implement the
read/write function associated with the device driver to pass data. You are
using read/write every time you do an echo into a <code>/dev/tty</code>.</p>
<p>Furthermore, the kernel provides a means to configure drivers or inform you about
stats through <code>/sys</code> and <code>/proc</code> file system. This could be used as the stdout
of the game. TBD</p>
<h1 id="here-is-where-it-became-complicated">Here is where it became complicated</h1>
<p>The <a href="https://github.com/Rust-for-Linux/">Rust kernel</a> copies over the current
content of <a href="https://github.com/rust-lang/rust">rust-lang</a> into the <code>rust</code>
directory, and adds kernel specific code to <code>rust/kernel</code>. Not all functions can
be used in the kernel though. You don&rsquo;t want to use functions that could panic
in the kernel, because then the whole system will panic. Therefore, you cannot
just use the function <code>collect</code> to create a Vector, you would have to use
<code>try_collect</code> - which is <a href="https://github.com/rust-lang/rust/issues/94047">not implemented yet</a>.</p>
<h1 id="tldr">TL;DR</h1>
<p>If you ever wanted to port <a href="https://github.com/domenukk/quarto_rs/tree/main">this game</a>
to the kernel, you would need to:</p>
<ul>
<li>Change imports of <code>std::</code> lib to use <code>kernel::</code></li>
<li>Change io through stdin/stdout to use for example read/write of a char
dev or /sys</li>
<li>Implement trait <code>try_collect</code> for Vec type to <a href="https://github.com/rust-lang/rust/issues/94047">rust-lang</a></li>
</ul>
<p>This is not an exhaustive list.</p>
<p>Problems encountered:</p>
<p>Rust specific:</p>
<p>HashSet needed implementing, but we can have 64 Pieces max, so it could have
been done with Vec as well.
hashbrown: <a href="https://github.com/rust-lang/hashbrown">https://github.com/rust-lang/hashbrown</a>, but it has a lot of
dependencies as well, which we cannot depend on. Since it is just comparing max
64 pieces, we could have rewritten the HashSet into Vec, but implementing a
HashSet is also nice.</p>
<p>remove all std:: stuff, comment out or replace by core::
println &ndash;&gt; printk
std::time:: &ndash;&gt; TBD</p>
<p>Kernel specific:
Makefile and Kconfig file for out of tree kernel module</p>

</main>

  <footer>
  
  
  <hr/>
  © <a href="https://chrysh.github.io">Christina Quast</a> 2024 &ndash; 2024 | <a href="https://github.com/chrysh">Github</a>
  
  </footer>
  </body>
</html>

