<!DOCTYPE html>
<html lang="en-us">
  <head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>Error handling | Linux kernel programming blog</title>
    <link rel="stylesheet" href="/css/style.css" />
    <link rel="stylesheet" href="/css/fonts.css" />
    
  </head>

  <body>
    <nav>
    <ul class="menu">
      
      <li><a href="/">Home</a></li>
      
      <li><a href="/post/">Posts</a></li>
      
      <li><a href="/categories/">Categories</a></li>
      
      <li><a href="/about/">About</a></li>
      
    </ul>
    <hr/>
    </nav>

<div class="article-meta">
<h1><span class="title">Error handling</span></h1>


</div>

<main>
<p><a href="https://github.com/Rust-for-Linux/"><img src="/static/img/rusty_penguin_7.jpeg" style="max-width:40%;min-width:40px;float:right;padding:40px" alt="Rusty penguin. Created by DALL·E 3." /></a></p>
<h1 id="error-handling-in-rust">Error handling in Rust</h1>
<h2 id="c-vs-rust">C vs Rust</h2>
<p>In C, functions could return a positive integer and this could mean an error or
not, depending on the function. Rust on the other hand has explicit error types.
The Result type encapsulates error and success.</p>
<p>Let&rsquo;s look at the following code, that tries to open a file. This operation
could fail.</p>
<pre><code>use std::fs::File;

fn open_file(path: &amp;str) -&gt; Result&lt;File, std::io::Error&gt; {
    File::open(path)
}
</code></pre>
<p>If the functions opened the file successfully, <code>Ok(file)</code> is returned. If it
fails, <code>Error(io::Error)</code> is returned.</p>
<p>When a function returns a pointer, and the operation fails, usually <code>NULL</code> is
returned to signal an error. Rust uses <code>Option&lt;T&gt;</code> for that.
The following function would return <code>Some(index)</code> if an item is found, and
<code>None</code> otherwise:</p>
<pre><code>TBD
</code></pre>
<p>The <code>?</code> operator than unwraps the <code>Ok</code> value.</p>
<p>When you write <code>expression?</code>, the Rust compiler expands it into something like
this:</p>
<pre><code>match expression {
    Ok(value) =&gt; value,
    Err(err) =&gt; return Err(From::from(err)),
}
</code></pre>
<pre><code>match expression {
    Some(value) =&gt; value,
    None =&gt; return None,
}
</code></pre>
<h1 id="kernel-land">Kernel Land</h1>
<h2 id="errorrs">error.rs</h2>
<p>The file <code>rust/kernel/error.rs</code> couples Rust errors to Linux
Kernel Code. It starts off by declaring a macro, which expands to the given name
and error code.</p>
<pre><code>macro_rules! declare_err {
    ($err:tt $(,)? $($doc:expr),+) =&gt; {
        $(
        #[doc = $doc]
        )*
        pub const $err: super::Error = super::Error(-(crate::bindings::$err as i32));
    };
}
</code></pre>
<p>This macro is used for all the errors used in the Linux kernel, and connects the
error code with its documentation.</p>
<pre><code>declare_err!(EPERM, &quot;Operation not permitted.&quot;);
declare_err!(ENOENT, &quot;No such file or directory.&quot;);
</code></pre>
<p>The first line expands to the following two lines:</p>
<pre><code>#[doc =  &quot;Operation not permitted.&quot;]
pub const EPERM: super::Error = super::Error(-(crate::bindings::EPERM as i32));
</code></pre>
<p>The error code is negated and cast to a i32 to match the type of <code>super::Error</code>.
This code declares a constant, <code>EPERM</code>, with the respective documentation</p>
<p>The <code>$(,)?</code> designator allows for an optional trailing comma. This means that
both those invocations are valid:</p>
<pre><code>declare_err!(EPERM, &quot;Operation not permitted.&quot;);
declare_err!(ENOENT, &quot;No such file or directory&quot;,);
</code></pre>
<h2 id="impl-error">impl Error</h2>
<pre><code>impl Error {

}
</code></pre>
<pre><code>impl From&lt;AllocError&gt; for Error {
    fn from(_: AllocError) -&gt; Error {
        code::ENOMEM
    }
}

impl From&lt;TryFromIntError&gt; for Error {
    fn from(_: TryFromIntError) -&gt; Error {
        code::EINVAL
    }
}
...
</code></pre>
<pre><code>impl From&lt;core::convert::Infallible&gt; for Error {
    fn from(e: core::convert::Infallible) -&gt; Error {
        match e {}
    }
}
</code></pre>
<pre><code>/// Converts an integer as returned by a C kernel function to an error if it's negative, and
/// `Ok(())` otherwise.
pub fn to_result(err: core::ffi::c_int) -&gt; Result {
    if err &lt; 0 {
        Err(Error::from_errno(err))
    } else {
        Ok(())
    }
}
</code></pre>
<pre><code>
</code></pre>
<p>TODO: Also show usages of this code</p>

</main>

  <footer>
  
  
  <hr/>
  © <a href="https://chrysh.github.io">Christina Quast</a> 2024 &ndash; 2024 | <a href="https://github.com/chrysh">Github</a>
  
  </footer>
  </body>
</html>

